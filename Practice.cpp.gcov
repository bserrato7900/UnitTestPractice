        -:    0:Source:Practice.cpp
        -:    0:Graph:Practice.gcno
        -:    0:Data:Practice.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "Practice.h"
        -:    2:#include <string>
        -:    3:
        -:    4:using std::string;
        -:    5:
        -:    6:// Receive three integers and rearrange their values so that they are in
        -:    7:// descending order from greatest (first) to least (third)
function _ZN8Practice14sortDescendingERiS0_S0_ called 1 returned 100% blocks executed 50%
        1:    8:void Practice::sortDescending(int & first, int & second, int & third)
        -:    9:{
        -:   10:  int biggest, middle, smallest;
        1:   11:  if( second > third && second > first )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:   12:  {
        1:   13:    biggest = second;
        -:   14:  }
    #####:   15:  else if( third > second && third > first )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   16:  {
    #####:   17:    biggest = third;
        -:   18:  }
        -:   19:  else
        -:   20:  {
    #####:   21:    biggest = first;
        -:   22:  }
        1:   23:  if( second < third && second < first )
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -:   24:  {
    #####:   25:    smallest = second;
        -:   26:  }
        1:   27:  else if( third < second && third < first )
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:   28:  {
        1:   29:    smallest = third;
        -:   30:  }
        -:   31:  else
        -:   32:  {
    #####:   33:    smallest = first;
        -:   34:  }
        1:   35:  if( first != biggest && first != smallest ){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:   36:    middle = first;
        -:   37:  }
    #####:   38:  else if( second != biggest && second != smallest ){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   39:    middle = second;
        -:   40:  }
        -:   41:  else{
    #####:   42:    middle = third;
        -:   43:  }
        1:   44:}
        -:   45:
        -:   46:// Receive a string and return whether or not it is strictly a palindrome,
        -:   47:// where it is spelled the same backwards and forwards when considering every
        -:   48:// character in the string, but disregarding case ('x' is the same as 'X')
function _ZN8Practice12isPalindromeENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 2 returned 100% blocks executed 96%
        2:   49:bool Practice::isPalindrome(string input)
        -:   50:{
       19:   51:  for(unsigned int i=0; i < input.size(); i++)
call    0 returned 100%
branch  1 taken 89% (fallthrough)
branch  2 taken 11%
        -:   52:  {
       17:   53:    if( input[i] < 'A' || input[i] > 'Z' )
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
        -:   54:    {
        -:   55:      //change lower case to upper case
       17:   56:      input[i] = input[i] - ('a' - 'A');
call    0 returned 100%
call    1 returned 100%
        -:   57:    }
        -:   58:  }
        -:   59:
        2:   60:  bool match = false;
        -:   61:
       10:   62:  for(unsigned int i=0; i < input.size()/2; i++)
call    0 returned 100%
branch  1 taken 80% (fallthrough)
branch  2 taken 20%
        -:   63:  {
        8:   64:    if( input[i] == input[input.size()-1-i] )
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
branch  3 taken 50% (fallthrough)
branch  4 taken 50%
        4:   65:      match = true;
        -:   66:    else
        4:   67:      match = false;
        -:   68:  }
        2:   69:  return match;
        -:   70:}
        -:   71:
        -:   72:// This function receives a string and counts how many times the same character
        -:   73:// is repeated at the beginning of the string, before any other characters. The
        -:   74:// function is case sensative so 'Z' is different than 'z'.
function _ZN8Practice22count_starting_repeatsENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 2 returned 100% blocks executed 100%
        2:   75:int Practice::count_starting_repeats(string word)
        -:   76:{
        2:   77:    int repetition = 0;
        2:   78:    int index = 0;
        -:   79:    char letter;
        -:   80:
        2:   81:    if( word.length() > 0 )
call    0 returned 100%
branch  1 taken 50% (fallthrough)
branch  2 taken 50%
        1:   82:      letter = word[0];
call    0 returned 100%
        -:   83:
        9:   84:    for(unsigned int i=1; i < word.length(); i++){
call    0 returned 100%
branch  1 taken 78% (fallthrough)
branch  2 taken 22%
        7:   85:      if( word[i] == letter ){
call    0 returned 100%
branch  1 taken 29% (fallthrough)
branch  2 taken 71%
        2:   86:        repetition++;
        -:   87:      }
        -:   88:    }
        -:   89:
        2:   90:    return repetition;
        -:   91:}
        -:   92:
        -:   93:// Receives an array that represents the hours someone sleeps each night of the week
        -:   94:// (as an array of seven integers) and returns a pointer to locate the first instance
        -:   95:// of an "all nighter" in the array (a day with 0 hours sleep) and returns the pointer.
        -:   96:// However, if there are no such days found, the function should return nullptr.
function _ZN8Practice10allnighterEPi called 1 returned 100% blocks executed 71%
        1:   97:int* Practice::allnighter(int sleep[7])
        -:   98:{
        1:   99:  int *ptr = &sleep[0];
        1:  100:  for(int i = 0; i < sizeof(&sleep); i++) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  101:     if(*ptr == 0){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  102:       return ptr;
        -:  103:     }
    #####:  104:     ptr++;
        -:  105:  }
    #####:  106:  return nullptr;
        -:  107:}
